"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const reader_1 = __importDefault(require("../reader"));
class Database {
    constructor(path) {
        this.isReady = false;
        this.index = [];
        this.indexLemmaIndex = new Map();
        this.indexOffsetIndex = new Map();
        this.data = [];
        this.dataLemmaIndex = new Map();
        this.dataOffsetIndex = new Map();
        this.path = path;
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            const reader = new reader_1.default(this);
            yield reader.init();
        });
    }
    ready() {
        this.isReady = true;
    }
    addIndex(index) {
        if (index.isComment) {
            return;
        }
        this.index.push(index);
        this.indexLemmaIndex.set(index.lemma, index);
        index.offsets.forEach((offset) => {
            let output = [];
            if (this.indexOffsetIndex.get(offset) !== undefined) {
                output = this.indexOffsetIndex.get(offset);
            }
            output.push(index);
            this.indexOffsetIndex.set(offset, output);
        });
    }
    static copyIndex(index) {
        const output = {
            lemma: index.lemma,
            pos: index.pos,
            offsetCount: index.offsetCount,
            pointerCount: index.pointerCount,
            pointers: [...index.pointers],
            senseCount: index.senseCount,
            tagSenseCount: index.tagSenseCount,
            offsets: [...index.offsets],
            isComment: index.isComment,
            offsetData: [...index.offsetData]
        };
        return output;
    }
    indexLemmaSearch(query) {
        const output = new Map();
        query.forEach((lemma) => {
            if ((lemma !== '') && (this.indexLemmaIndex.get(lemma) !== undefined)) {
                output.set(lemma, Database.copyIndex(this.indexLemmaIndex.get(lemma)));
            }
        });
        return output;
    }
    indexOffsetSearch(query) {
        const output = new Map();
        query.forEach((offset) => {
            if (offset && this.indexOffsetIndex.get(offset)) {
                const items = [];
                this.indexOffsetIndex.get(offset).forEach((item) => {
                    items.push(Database.copyIndex(item));
                });
                output.set(offset, items);
            }
        });
        return output;
    }
    addData(data) {
        if (data.isComment) {
            return;
        }
        this.data.push(data);
        this.dataOffsetIndex.set(data.offset, data);
        data.words.forEach((word) => {
            let output = [];
            if (this.dataLemmaIndex.get(word)) {
                output = this.dataLemmaIndex.get(word);
            }
            output.push(data);
            this.dataLemmaIndex.set(word, output);
        });
    }
    static copyData(data) {
        return {
            offset: data.offset,
            pos: data.pos,
            wordCount: data.wordCount,
            words: [...data.words],
            pointerCnt: data.pointerCnt,
            pointers: [...data.pointers],
            glossary: [...data.glossary],
            isComment: data.isComment
        };
    }
    dataLemmaSearch(query) {
        const output = new Map();
        query.forEach((lemma) => {
            const items = [];
            if ((lemma !== '') && this.dataLemmaIndex.get(lemma)) {
                this.dataLemmaIndex.get(lemma).forEach((item) => {
                    items.push(Database.copyData(item));
                });
            }
            output.set(lemma, items);
        });
        return output;
    }
    dataOffsetSearch(query) {
        const output = new Map();
        query.forEach((offset) => {
            if (offset && this.dataOffsetIndex.get(offset)) {
                output.set(offset, Database.copyData(this.dataOffsetIndex.get(offset)));
            }
        });
        return output;
    }
    getSize() {
        return {
            count: this.index.length + this.data.length,
            indexes: this.indexOffsetIndex.size
                + this.indexLemmaIndex.size
                + this.dataOffsetIndex.size
                + this.dataLemmaIndex.size
        };
    }
}
exports.default = Database;
