"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const readline_1 = __importDefault(require("readline"));
const fs_1 = __importDefault(require("fs"));
const index_line_1 = __importDefault(require("../parser/index.line"));
const data_line_1 = __importDefault(require("../parser/data.line"));
const fileTypes = ['index', 'data'];
const wordTypes = ['adj', 'adv', 'noun', 'verb'];
class Reader {
    constructor(db) {
        this.db = db;
        this.isReady = false;
        this.readRemaining = 8;
    }
    init() {
        return new Promise((resolve, reject) => {
            fileTypes.forEach((fileType) => {
                wordTypes.forEach((wordType) => {
                    const file = `${this.db.path}/${fileType}.${wordType}`;
                    const readerInterface = readline_1.default.createInterface({
                        input: fs_1.default.createReadStream(file),
                        output: undefined
                    });
                    readerInterface.on('line', (line) => {
                        if (fileType === 'index') {
                            const item = new index_line_1.default().parse(line);
                            this.db.addIndex(item);
                        }
                        else {
                            const item = new data_line_1.default().parse(line);
                            this.db.addData(item);
                        }
                    });
                    readerInterface.on('close', () => {
                        this.readRemaining -= 1;
                        if (this.readRemaining === 0) {
                            this.isReady = true;
                            this.db.ready();
                            resolve();
                        }
                    });
                    readerInterface.on('error', () => {
                        reject();
                    });
                    // Ignoring close, pause, resume, SIGCONT, SIGINT, SIGTSTP
                });
            });
        });
    }
}
exports.default = Reader;
