"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const database_1 = __importDefault(require("../database"));
class Dictionary {
    constructor(path) {
        this.path = path;
        this.database = new database_1.default(this.path);
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.database.init();
        });
    }
    searchFor(term) {
        let output = new Map();
        output = this.database.indexLemmaSearch(term);
        output.forEach((index, lemma) => {
            const lemmaData = this.searchOffsetsInDataFor(index.offsets);
            index.offsetData = [];
            lemmaData.forEach((data) => {
                index.offsetData.push(data);
            });
            output.set(lemma, index);
        });
        return output;
    }
    searchOffsetsInDataFor(offsets) {
        return this.database.dataOffsetSearch(offsets);
    }
    searchSimpleFor(words) {
        const output = new Map();
        const result = this.searchFor(words);
        result.forEach((index, lemma) => {
            if (index.offsetData.length > 0) {
                let meaning = '';
                const firstWords = index.offsetData[0].words.join(', ');
                if (index.offsetData[0].glossary.length > 0) {
                    meaning = index.offsetData[0].glossary[0];
                }
                output.set(lemma, {
                    words: firstWords,
                    meaning: meaning,
                    lemma: lemma
                });
            }
        });
        return output;
    }
    wordsStartingWith(prefix) {
        let output = [];
        if (prefix !== '') {
            output = this.database
                .index
                .filter(item => item.lemma.startsWith(prefix))
                .map(item => item.lemma);
        }
        return output;
    }
    wordsEndingWith(suffix) {
        let output = [];
        if (suffix !== '') {
            output = this.database
                .index
                .filter(item => item.lemma.endsWith(suffix))
                .map(item => item.lemma);
        }
        return output;
    }
    wordsIncluding(word) {
        let output = [];
        if (word !== '') {
            output = this.database
                .index
                .filter(item => item.lemma.includes(word))
                .map(item => item.lemma);
        }
        return output;
    }
    wordsUsingAllCharactersFrom(query, ignorePhrases = true) {
        let output = [];
        if (query === '') {
            return output;
        }
        const querySplit = query.split('').sort();
        output = this.database
            .index
            .filter((item) => {
            const lemmaSplit = item.lemma.split('').sort();
            if (ignorePhrases && (lemmaSplit.includes('_') || lemmaSplit.includes('-'))) {
                return false;
            }
            for (let i = 0; i < querySplit.length; i += 1) {
                const found = lemmaSplit.indexOf(querySplit[i]);
                if (found < 0) {
                    return false;
                }
                lemmaSplit.splice(found, 1);
            }
            return true;
        })
            .map(item => item.lemma);
        return output;
    }
    wordsWithCharsIn(query, priorityCharacters = '') {
        const matchingWords = this.database
            .index
            .filter(item => Dictionary.hasAllCharsIn(query, item.lemma))
            .map(item => item.lemma)
            .sort((a, b) => {
            let diff = 0;
            if (priorityCharacters.length > 0) {
                const aPriority = Dictionary.hasAllCharsIn(a, priorityCharacters) ? 10 : 0;
                const bPriority = Dictionary.hasAllCharsIn(b, priorityCharacters) ? 10 : 0;
                diff = (b.length + bPriority) - (a.length + aPriority);
            }
            else {
                diff = b.length - a.length;
            }
            return diff;
        })
            .splice(0, 10);
        return this.searchSimpleFor(matchingWords);
    }
    static hasAllCharsIn(word, test) {
        const wordSplit = word.split('').sort();
        const testSplit = test.split('').sort();
        if (testSplit.length > wordSplit.length) {
            return false;
        }
        for (let i = 0; i < testSplit.length; i += 1) {
            const foundChar = wordSplit.indexOf(testSplit[i]);
            if (foundChar < 0) {
                return false;
            }
            wordSplit.splice(foundChar, 1);
        }
        return true;
    }
}
exports.default = Dictionary;
